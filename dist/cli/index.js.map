{"version":3,"sources":["../../src/cli/index.ts","../../src/cli/commands/init.ts","../../src/index.ts","../../src/cli/commands/apply.ts"],"sourcesContent":["import { program } from 'commander';\nimport { spawn } from 'child_process';\nimport pc from 'picocolors';\nimport { init } from './commands/init.js';\nimport { apply } from './commands/apply.js';\nimport { VERSION } from '../index.js';\n\nprogram\n  .name('tkhrn-ruler')\n  .description('Frontend common ruleset CLI for AI agents')\n  .version(VERSION);\n\n// Custom init command\nprogram\n  .command('init')\n  .description('Initialize tkhrn-ruler in current project')\n  .option('-i, --interactive', 'Interactive mode for selecting options')\n  .option('--skip-env', 'Skip .env.mcp.example setup')\n  .option('--skip-gitignore', 'Skip .gitignore modification')\n  .action(init);\n\n// Custom apply command with command copying\nprogram\n  .command('apply', { isDefault: false })\n  .description('Apply rules and copy custom commands to configured agents')\n  .option('--nested', 'Include nested .ruler directories')\n  .allowUnknownOption(true)\n  .action(async () => {\n    const nested = process.argv.includes('--nested');\n    await apply({ nested });\n  });\n\nprogram\n  .command('revert')\n  .description('Revert applied rules (passthrough to ruler)')\n  .allowUnknownOption(true)\n  .action(() => passthrough('revert'));\n\n// Catch-all for any other ruler commands\nprogram\n  .arguments('<command> [args...]')\n  .allowUnknownOption(true)\n  .action((command: string) => passthrough(command));\n\nfunction passthrough(command: string) {\n  const args = process.argv.slice(process.argv.indexOf(command));\n\n  console.log(pc.dim(`‚Üí ruler ${args.join(' ')}`));\n\n  const child = spawn('ruler', args, {\n    stdio: 'inherit',\n    shell: true,\n  });\n\n  child.on('error', (err) => {\n    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n      console.error(pc.red('\\nError: ruler is not installed.'));\n      console.error(pc.dim('Install it with: npm install -g @intellectronica/ruler'));\n      process.exit(1);\n    }\n    console.error(pc.red(`Error: ${err.message}`));\n    process.exit(1);\n  });\n\n  child.on('close', (code) => {\n    process.exit(code ?? 0);\n  });\n}\n\nprogram.parse();\n","import { spawn } from 'child_process';\nimport { existsSync, appendFileSync, readFileSync, writeFileSync, readdirSync, renameSync, mkdirSync, cpSync } from 'fs';\nimport { join, basename } from 'path';\nimport { tmpdir } from 'os';\nimport pc from 'picocolors';\nimport { REPO } from '../../index.js';\n\ninterface InitOptions {\n  interactive?: boolean;\n  skipEnv?: boolean;\n  skipGitignore?: boolean;\n}\n\nexport async function init(options: InitOptions) {\n  const cwd = process.cwd();\n  const rulerDir = join(cwd, '.ruler');\n  const rulerExists = existsSync(rulerDir);\n\n  console.log(pc.bold('\\nüöÄ Initializing tkhrn-ruler...\\n'));\n\n  // Step 1: Download .ruler directory using degit\n  console.log(pc.dim('‚Üí Downloading ruleset...'));\n\n  try {\n    if (rulerExists) {\n      // Download to temp directory first, then merge\n      const tempDir = join(tmpdir(), `tkhrn-ruler-${Date.now()}`);\n      mkdirSync(tempDir, { recursive: true });\n\n      await runCommand('npx', ['degit', `${REPO}/.ruler`, tempDir, '--force']);\n\n      // Merge files, backup duplicates\n      const downloadedFiles = readdirSync(tempDir);\n      let backedUp = 0;\n      let added = 0;\n\n      for (const file of downloadedFiles) {\n        const targetPath = join(rulerDir, file);\n        const sourcePath = join(tempDir, file);\n\n        if (existsSync(targetPath) && file.endsWith('.md')) {\n          // Backup existing file\n          const bakName = file.replace(/\\.md$/, '.bak.md');\n          const bakPath = join(rulerDir, bakName);\n          renameSync(targetPath, bakPath);\n          backedUp++;\n          console.log(pc.yellow(`  ‚Ü≥ Backed up ${file} ‚Üí ${bakName}`));\n        }\n\n        // Copy new file\n        cpSync(sourcePath, targetPath, { recursive: true });\n        added++;\n      }\n\n      console.log(pc.green(`‚úì .ruler directory updated (${added} files added, ${backedUp} backed up)`));\n    } else {\n      await runCommand('npx', ['degit', `${REPO}/.ruler`, '.ruler']);\n      console.log(pc.green('‚úì .ruler directory created'));\n    }\n  } catch (error) {\n    console.error(pc.red('‚úó Failed to download ruleset'));\n    process.exit(1);\n  }\n\n  // Step 2: Download .env.mcp.example\n  if (!options.skipEnv) {\n    console.log(pc.dim('‚Üí Downloading MCP environment template...'));\n\n    try {\n      await runCommand('npx', ['degit', `${REPO}/.env.mcp.example`, '.env.mcp.example', '--force']);\n      console.log(pc.green('‚úì .env.mcp.example created'));\n    } catch {\n      // If degit fails for single file, create it manually\n      console.log(pc.yellow('‚ö†Ô∏è  Could not download .env.mcp.example, creating empty template'));\n      await createEnvTemplate(cwd);\n    }\n  }\n\n  // Step 3: Update .gitignore\n  if (!options.skipGitignore) {\n    updateGitignore(cwd);\n  }\n\n  // Step 4: Run ruler init if ruler is installed\n  console.log(pc.dim('‚Üí Running ruler init...'));\n\n  try {\n    await runCommand('ruler', ['init'], { silent: true });\n    console.log(pc.green('‚úì Ruler initialized'));\n  } catch {\n    console.log(pc.yellow('‚ö†Ô∏è  ruler not found, skipping ruler init'));\n    console.log(pc.dim('   Install ruler: npm install -g @intellectronica/ruler'));\n  }\n\n  // Done\n  console.log(pc.bold(pc.green('\\n‚úÖ tkhrn-ruler initialized successfully!\\n')));\n  console.log(pc.dim('Next steps:'));\n  console.log(pc.dim('  1. Configure MCP tokens in .env.mcp.local'));\n  console.log(pc.dim('  2. Run \"tkhrn-ruler apply\" to apply rules'));\n  console.log('');\n}\n\nfunction runCommand(\n  command: string,\n  args: string[],\n  options: { silent?: boolean } = {}\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const child = spawn(command, args, {\n      stdio: options.silent ? 'ignore' : 'inherit',\n      shell: true,\n    });\n\n    child.on('error', reject);\n    child.on('close', (code) => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(`Command failed with code ${code}`));\n      }\n    });\n  });\n}\n\nfunction updateGitignore(cwd: string) {\n  const gitignorePath = join(cwd, '.gitignore');\n  const additions = `\n# Agent Handover Context\n.handover/\n\n# MCP tokens\n.env.mcp.local\n`;\n\n  if (existsSync(gitignorePath)) {\n    const content = readFileSync(gitignorePath, 'utf-8');\n\n    if (!content.includes('.handover/')) {\n      appendFileSync(gitignorePath, additions);\n      console.log(pc.green('‚úì .gitignore updated'));\n    } else {\n      console.log(pc.dim('  .gitignore already configured'));\n    }\n  } else {\n    writeFileSync(gitignorePath, additions.trim() + '\\n');\n    console.log(pc.green('‚úì .gitignore created'));\n  }\n}\n\nasync function createEnvTemplate(cwd: string) {\n  const template = `# MCP Server Tokens\n# Copy this file to .env.mcp.local and add your tokens\n\n# Figma - Design token extraction\nFIGMA_ACCESS_TOKEN=\n\n# Notion - Documentation access\nNOTION_API_KEY=\n`;\n\n  writeFileSync(join(cwd, '.env.mcp.example'), template);\n  console.log(pc.green('‚úì .env.mcp.example created'));\n}\n","// tkhrn-ruler - Frontend common ruleset for AI agents\n// Main entry point for programmatic usage\n\nexport const VERSION = '0.1.0';\nexport const REPO = 'ginameee/tkhrn-ruler';\n","import { spawn } from 'child_process';\nimport { existsSync, readdirSync, copyFileSync, mkdirSync, readFileSync, renameSync } from 'fs';\nimport { join, basename, extname } from 'path';\nimport pc from 'picocolors';\nimport { parse } from '@iarna/toml';\n\ninterface AgentConfig {\n  enabled?: boolean;\n  output_path?: string;\n  command_path?: string;\n  skills_path?: string;\n  subagents_path?: string;\n}\n\ninterface RulerConfig {\n  agents?: {\n    [key: string]: AgentConfig;\n  };\n}\n\n// Default command paths for each agent\n// These are used as fallback if not specified in ruler.toml\nconst DEFAULT_COMMAND_PATHS: Record<string, string> = {\n  cursor: '.cursor/commands',\n  claude: '.claude/commands',\n  codex: '.codex/commands',\n};\n\n// Default skills paths for each agent\nconst DEFAULT_SKILLS_PATHS: Record<string, string> = {\n  cursor: '.cursor/skills',\n  claude: '.claude/skills',\n  codex: '.codex/skills',\n};\n\n// Default subagents paths for each agent\nconst DEFAULT_SUBAGENTS_PATHS: Record<string, string> = {\n  cursor: '.cursor/subagents',\n  claude: '.claude/commands', // Claude treats subagents as commands\n  codex: '.codex/subagents',\n};\n\nexport async function apply(options: { nested?: boolean } = {}) {\n  const cwd = process.cwd();\n  const rulerPath = join(cwd, '.ruler');\n  const rulerTomlPath = join(rulerPath, 'ruler.toml');\n\n  // Check if .ruler exists\n  if (!existsSync(rulerPath)) {\n    console.error(pc.red('Error: .ruler directory not found.'));\n    console.error(pc.dim('Run \"tkhrn-ruler init\" first.'));\n    process.exit(1);\n  }\n\n  // Parse ruler.toml to get agent configurations\n  let config: RulerConfig = {};\n  if (existsSync(rulerTomlPath)) {\n    try {\n      const tomlContent = readFileSync(rulerTomlPath, 'utf-8');\n      config = parse(tomlContent) as RulerConfig;\n    } catch (error) {\n      console.warn(pc.yellow('Warning: Could not parse ruler.toml'));\n    }\n  }\n\n  // First, run ruler apply\n  console.log(pc.dim('‚Üí Running ruler apply...'));\n  await runRulerApply(options.nested);\n\n  // Then, copy commands\n  console.log(pc.dim('\\n‚Üí Copying custom commands...'));\n  await copyCommands(cwd, config, options.nested);\n\n  // Copy skills\n  console.log(pc.dim('\\n‚Üí Copying skills...'));\n  await copySkills(cwd, config, options.nested);\n\n  // Copy subagents\n  console.log(pc.dim('\\n‚Üí Copying subagents...'));\n  await copySubagents(cwd, config, options.nested);\n\n  console.log(pc.bold(pc.green('\\n‚úÖ Rules, commands, skills, and subagents applied successfully!\\n')));\n}\n\nasync function runRulerApply(nested?: boolean): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const args = ['apply'];\n    if (nested) {\n      args.push('--nested');\n    }\n\n    const child = spawn('ruler', args, {\n      stdio: 'inherit',\n      shell: true,\n    });\n\n    child.on('error', (err) => {\n      if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n        console.error(pc.red('\\nError: ruler is not installed.'));\n        console.error(pc.dim('Install it with: npm install -g @intellectronica/ruler'));\n        reject(err);\n        return;\n      }\n      reject(err);\n    });\n\n    child.on('close', (code) => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(`ruler apply failed with code ${code}`));\n      }\n    });\n  });\n}\n\nasync function copyCommands(\n  cwd: string,\n  config: RulerConfig,\n  nested?: boolean\n): Promise<void> {\n  const rulerCommandsPath = join(cwd, '.ruler', 'commands');\n\n  // If commands directory doesn't exist, skip\n  if (!existsSync(rulerCommandsPath)) {\n    console.log(pc.dim('  No .ruler/commands directory found, skipping command copy'));\n    return;\n  }\n\n  const agents = config.agents || {};\n  const defaultAgents = ['cursor', 'claude', 'codex'];\n\n  // Copy common commands to all enabled agents\n  for (const agentName of defaultAgents) {\n    const agentConfig = agents[agentName] || {};\n    \n    // Skip if agent is disabled\n    if (agentConfig.enabled === false) {\n      continue;\n    }\n\n    // Determine destination path\n    const commandPath = agentConfig.command_path || DEFAULT_COMMAND_PATHS[agentName];\n    if (!commandPath) {\n      console.warn(pc.yellow(`  Warning: No command_path configured for ${agentName}, skipping`));\n      continue;\n    }\n\n    const destPath = join(cwd, commandPath);\n    \n    // Copy common commands to this agent's command directory\n    try {\n      copyCommandsWithBackup(rulerCommandsPath, destPath);\n      console.log(pc.green(`  ‚úì Copied commands to ${agentName} ‚Üí ${commandPath}`));\n    } catch (error) {\n      console.error(pc.red(`  ‚úó Failed to copy commands to ${agentName}: ${error}`));\n    }\n  }\n\n  // Handle nested commands if nested option is enabled\n  if (nested) {\n    await copyNestedCommands(cwd, config);\n  }\n}\n\nasync function copyNestedCommands(\n  cwd: string,\n  config: RulerConfig\n): Promise<void> {\n  // Find all nested .ruler directories\n  const nestedRulers = findNestedRulers(cwd);\n  \n  for (const nestedRulerPath of nestedRulers) {\n    const nestedCommandsPath = join(nestedRulerPath, 'commands');\n    \n    if (!existsSync(nestedCommandsPath)) {\n      continue;\n    }\n\n    // Get relative path from cwd to determine nested project path\n    const relativePath = nestedRulerPath\n      .replace(cwd, '')\n      .replace(/\\\\.ruler$/, '')\n      .replace(/^\\//, '')\n      .replace(/^\\\\/, '');\n    const nestedProjectPath = relativePath ? join(cwd, relativePath) : cwd;\n\n    const agents = config.agents || {};\n    const defaultAgents = ['cursor', 'claude', 'codex'];\n\n    // Copy common commands from nested .ruler/commands to all enabled agents\n    for (const agentName of defaultAgents) {\n      const agentConfig = agents[agentName] || {};\n      \n      if (agentConfig.enabled === false) {\n        continue;\n      }\n\n      const commandPath = agentConfig.command_path || DEFAULT_COMMAND_PATHS[agentName];\n      if (!commandPath) {\n        continue;\n      }\n\n      // For nested, append to nested project path\n      const destPath = join(nestedProjectPath, commandPath);\n      \n      try {\n        copyCommandsWithBackup(nestedCommandsPath, destPath);\n        console.log(pc.green(`  ‚úì Copied nested commands to ${agentName} in ${relativePath} ‚Üí ${commandPath}`));\n      } catch (error) {\n        console.error(pc.red(`  ‚úó Failed to copy nested commands to ${agentName} in ${relativePath}: ${error}`));\n      }\n    }\n  }\n}\n\nfunction findNestedRulers(rootPath: string, currentPath: string = rootPath, results: string[] = []): string[] {\n  try {\n    const entries = readdirSync(currentPath, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      // Skip node_modules, .git, dist, etc.\n      if (entry.name.startsWith('.') && entry.name !== '.ruler') {\n        continue;\n      }\n      if (entry.name === 'node_modules' || entry.name === 'dist' || entry.name === '.git') {\n        continue;\n      }\n\n      const fullPath = join(currentPath, entry.name);\n      \n      if (entry.isDirectory()) {\n        if (entry.name === '.ruler' && fullPath !== join(rootPath, '.ruler')) {\n          results.push(fullPath);\n        } else {\n          findNestedRulers(rootPath, fullPath, results);\n        }\n      }\n    }\n  } catch (error) {\n    // Ignore permission errors\n  }\n  \n  return results;\n}\n\n/**\n * Copy commands from source to destination with backup support.\n * If a file with the same name exists, it will be backed up as {filename}.bak.md\n */\nfunction copyCommandsWithBackup(source: string, dest: string): void {\n  // Create destination directory if it doesn't exist\n  if (!existsSync(dest)) {\n    mkdirSync(dest, { recursive: true });\n  }\n\n  const entries = readdirSync(source, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const sourcePath = join(source, entry.name);\n    const destPath = join(dest, entry.name);\n\n    if (entry.isDirectory()) {\n      // Recursively copy subdirectories\n      copyCommandsWithBackup(sourcePath, destPath);\n    } else {\n      // Skip .gitkeep files\n      if (entry.name === '.gitkeep') {\n        continue;\n      }\n\n      // If destination file exists, backup it first\n      if (existsSync(destPath)) {\n        const fileName = basename(destPath, extname(destPath));\n        const fileExt = extname(destPath);\n        const backupPath = join(dest, `${fileName}.bak${fileExt}`);\n        \n        try {\n          renameSync(destPath, backupPath);\n          console.log(pc.dim(`    ‚Üí Backed up existing file: ${entry.name} ‚Üí ${basename(backupPath)}`));\n        } catch (error) {\n          console.warn(pc.yellow(`    ‚ö† Could not backup ${entry.name}, skipping...`));\n          continue;\n        }\n      }\n\n      // Copy the new file\n      copyFileSync(sourcePath, destPath);\n    }\n  }\n}\n\n/**\n * Copy skills from .ruler/skills to agent-specific skills directories\n */\nasync function copySkills(\n  cwd: string,\n  config: RulerConfig,\n  nested?: boolean\n): Promise<void> {\n  const rulerSkillsPath = join(cwd, '.ruler', 'skills');\n\n  // If skills directory doesn't exist, skip\n  if (!existsSync(rulerSkillsPath)) {\n    console.log(pc.dim('  No .ruler/skills directory found, skipping skills copy'));\n    return;\n  }\n\n  const agents = config.agents || {};\n  const defaultAgents = ['cursor', 'claude', 'codex'];\n\n  // Copy skills to all enabled agents\n  for (const agentName of defaultAgents) {\n    const agentConfig = agents[agentName] || {};\n\n    // Skip if agent is disabled\n    if (agentConfig.enabled === false) {\n      continue;\n    }\n\n    // Determine destination path\n    const skillsPath = agentConfig.skills_path || DEFAULT_SKILLS_PATHS[agentName];\n    if (!skillsPath) {\n      console.warn(pc.yellow(`  Warning: No skills_path configured for ${agentName}, skipping`));\n      continue;\n    }\n\n    const destPath = join(cwd, skillsPath);\n\n    // Copy skills to this agent's skills directory\n    try {\n      copyCommandsWithBackup(rulerSkillsPath, destPath);\n      console.log(pc.green(`  ‚úì Copied skills to ${agentName} ‚Üí ${skillsPath}`));\n    } catch (error) {\n      console.error(pc.red(`  ‚úó Failed to copy skills to ${agentName}: ${error}`));\n    }\n  }\n\n  // Handle nested skills if nested option is enabled\n  if (nested) {\n    await copyNestedSkills(cwd, config);\n  }\n}\n\n/**\n * Copy nested skills from sub-projects\n */\nasync function copyNestedSkills(\n  cwd: string,\n  config: RulerConfig\n): Promise<void> {\n  const nestedRulers = findNestedRulers(cwd);\n\n  for (const nestedRulerPath of nestedRulers) {\n    const nestedSkillsPath = join(nestedRulerPath, 'skills');\n\n    if (!existsSync(nestedSkillsPath)) {\n      continue;\n    }\n\n    const relativePath = nestedRulerPath\n      .replace(cwd, '')\n      .replace(/\\\\.ruler$/, '')\n      .replace(/^\\//, '')\n      .replace(/^\\\\/, '');\n    const nestedProjectPath = relativePath ? join(cwd, relativePath) : cwd;\n\n    const agents = config.agents || {};\n    const defaultAgents = ['cursor', 'claude', 'codex'];\n\n    for (const agentName of defaultAgents) {\n      const agentConfig = agents[agentName] || {};\n\n      if (agentConfig.enabled === false) {\n        continue;\n      }\n\n      const skillsPath = agentConfig.skills_path || DEFAULT_SKILLS_PATHS[agentName];\n      if (!skillsPath) {\n        continue;\n      }\n\n      const destPath = join(nestedProjectPath, skillsPath);\n\n      try {\n        copyCommandsWithBackup(nestedSkillsPath, destPath);\n        console.log(pc.green(`  ‚úì Copied nested skills to ${agentName} in ${relativePath} ‚Üí ${skillsPath}`));\n      } catch (error) {\n        console.error(pc.red(`  ‚úó Failed to copy nested skills to ${agentName} in ${relativePath}: ${error}`));\n      }\n    }\n  }\n}\n\n/**\n * Copy subagents from .ruler/subagents to agent-specific subagents directories\n */\nasync function copySubagents(\n  cwd: string,\n  config: RulerConfig,\n  nested?: boolean\n): Promise<void> {\n  const rulerSubagentsPath = join(cwd, '.ruler', 'subagents');\n\n  // If subagents directory doesn't exist, skip\n  if (!existsSync(rulerSubagentsPath)) {\n    console.log(pc.dim('  No .ruler/subagents directory found, skipping subagents copy'));\n    return;\n  }\n\n  const agents = config.agents || {};\n  const defaultAgents = ['cursor', 'claude', 'codex'];\n\n  // Copy subagents to all enabled agents\n  for (const agentName of defaultAgents) {\n    const agentConfig = agents[agentName] || {};\n\n    // Skip if agent is disabled\n    if (agentConfig.enabled === false) {\n      continue;\n    }\n\n    // Determine destination path\n    const subagentsPath = agentConfig.subagents_path || DEFAULT_SUBAGENTS_PATHS[agentName];\n    if (!subagentsPath) {\n      console.warn(pc.yellow(`  Warning: No subagents_path configured for ${agentName}, skipping`));\n      continue;\n    }\n\n    const destPath = join(cwd, subagentsPath);\n\n    // Copy subagents to this agent's subagents directory\n    try {\n      copyCommandsWithBackup(rulerSubagentsPath, destPath);\n      console.log(pc.green(`  ‚úì Copied subagents to ${agentName} ‚Üí ${subagentsPath}`));\n    } catch (error) {\n      console.error(pc.red(`  ‚úó Failed to copy subagents to ${agentName}: ${error}`));\n    }\n  }\n\n  // Handle nested subagents if nested option is enabled\n  if (nested) {\n    await copyNestedSubagents(cwd, config);\n  }\n}\n\n/**\n * Copy nested subagents from sub-projects\n */\nasync function copyNestedSubagents(\n  cwd: string,\n  config: RulerConfig\n): Promise<void> {\n  const nestedRulers = findNestedRulers(cwd);\n\n  for (const nestedRulerPath of nestedRulers) {\n    const nestedSubagentsPath = join(nestedRulerPath, 'subagents');\n\n    if (!existsSync(nestedSubagentsPath)) {\n      continue;\n    }\n\n    const relativePath = nestedRulerPath\n      .replace(cwd, '')\n      .replace(/\\\\.ruler$/, '')\n      .replace(/^\\//, '')\n      .replace(/^\\\\/, '');\n    const nestedProjectPath = relativePath ? join(cwd, relativePath) : cwd;\n\n    const agents = config.agents || {};\n    const defaultAgents = ['cursor', 'claude', 'codex'];\n\n    for (const agentName of defaultAgents) {\n      const agentConfig = agents[agentName] || {};\n\n      if (agentConfig.enabled === false) {\n        continue;\n      }\n\n      const subagentsPath = agentConfig.subagents_path || DEFAULT_SUBAGENTS_PATHS[agentName];\n      if (!subagentsPath) {\n        continue;\n      }\n\n      const destPath = join(nestedProjectPath, subagentsPath);\n\n      try {\n        copyCommandsWithBackup(nestedSubagentsPath, destPath);\n        console.log(pc.green(`  ‚úì Copied nested subagents to ${agentName} in ${relativePath} ‚Üí ${subagentsPath}`));\n      } catch (error) {\n        console.error(pc.red(`  ‚úó Failed to copy nested subagents to ${agentName} in ${relativePath}: ${error}`));\n      }\n    }\n  }\n}\n\n/**\n * Legacy function for backward compatibility (not used anymore)\n * @deprecated Use copyCommandsWithBackup instead\n */\nfunction copyDirectory(source: string, dest: string): void {\n  copyCommandsWithBackup(source, dest);\n}\n"],"mappings":";;;AAAA,SAAS,eAAe;AACxB,SAAS,SAAAA,cAAa;AACtB,OAAOC,SAAQ;;;ACFf,SAAS,aAAa;AACtB,SAAS,YAAY,gBAAgB,cAAc,eAAe,aAAa,YAAY,WAAW,cAAc;AACpH,SAAS,YAAsB;AAC/B,SAAS,cAAc;AACvB,OAAO,QAAQ;;;ACDR,IAAM,UAAU;AAChB,IAAM,OAAO;;;ADSpB,eAAsB,KAAK,SAAsB;AAC/C,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,WAAW,KAAK,KAAK,QAAQ;AACnC,QAAM,cAAc,WAAW,QAAQ;AAEvC,UAAQ,IAAI,GAAG,KAAK,2CAAoC,CAAC;AAGzD,UAAQ,IAAI,GAAG,IAAI,+BAA0B,CAAC;AAE9C,MAAI;AACF,QAAI,aAAa;AAEf,YAAM,UAAU,KAAK,OAAO,GAAG,eAAe,KAAK,IAAI,CAAC,EAAE;AAC1D,gBAAU,SAAS,EAAE,WAAW,KAAK,CAAC;AAEtC,YAAM,WAAW,OAAO,CAAC,SAAS,GAAG,IAAI,WAAW,SAAS,SAAS,CAAC;AAGvE,YAAM,kBAAkB,YAAY,OAAO;AAC3C,UAAI,WAAW;AACf,UAAI,QAAQ;AAEZ,iBAAW,QAAQ,iBAAiB;AAClC,cAAM,aAAa,KAAK,UAAU,IAAI;AACtC,cAAM,aAAa,KAAK,SAAS,IAAI;AAErC,YAAI,WAAW,UAAU,KAAK,KAAK,SAAS,KAAK,GAAG;AAElD,gBAAM,UAAU,KAAK,QAAQ,SAAS,SAAS;AAC/C,gBAAM,UAAU,KAAK,UAAU,OAAO;AACtC,qBAAW,YAAY,OAAO;AAC9B;AACA,kBAAQ,IAAI,GAAG,OAAO,sBAAiB,IAAI,WAAM,OAAO,EAAE,CAAC;AAAA,QAC7D;AAGA,eAAO,YAAY,YAAY,EAAE,WAAW,KAAK,CAAC;AAClD;AAAA,MACF;AAEA,cAAQ,IAAI,GAAG,MAAM,oCAA+B,KAAK,iBAAiB,QAAQ,aAAa,CAAC;AAAA,IAClG,OAAO;AACL,YAAM,WAAW,OAAO,CAAC,SAAS,GAAG,IAAI,WAAW,QAAQ,CAAC;AAC7D,cAAQ,IAAI,GAAG,MAAM,iCAA4B,CAAC;AAAA,IACpD;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,MAAM,GAAG,IAAI,mCAA8B,CAAC;AACpD,YAAQ,KAAK,CAAC;AAAA,EAChB;AAGA,MAAI,CAAC,QAAQ,SAAS;AACpB,YAAQ,IAAI,GAAG,IAAI,gDAA2C,CAAC;AAE/D,QAAI;AACF,YAAM,WAAW,OAAO,CAAC,SAAS,GAAG,IAAI,qBAAqB,oBAAoB,SAAS,CAAC;AAC5F,cAAQ,IAAI,GAAG,MAAM,iCAA4B,CAAC;AAAA,IACpD,QAAQ;AAEN,cAAQ,IAAI,GAAG,OAAO,4EAAkE,CAAC;AACzF,YAAM,kBAAkB,GAAG;AAAA,IAC7B;AAAA,EACF;AAGA,MAAI,CAAC,QAAQ,eAAe;AAC1B,oBAAgB,GAAG;AAAA,EACrB;AAGA,UAAQ,IAAI,GAAG,IAAI,8BAAyB,CAAC;AAE7C,MAAI;AACF,UAAM,WAAW,SAAS,CAAC,MAAM,GAAG,EAAE,QAAQ,KAAK,CAAC;AACpD,YAAQ,IAAI,GAAG,MAAM,0BAAqB,CAAC;AAAA,EAC7C,QAAQ;AACN,YAAQ,IAAI,GAAG,OAAO,oDAA0C,CAAC;AACjE,YAAQ,IAAI,GAAG,IAAI,yDAAyD,CAAC;AAAA,EAC/E;AAGA,UAAQ,IAAI,GAAG,KAAK,GAAG,MAAM,kDAA6C,CAAC,CAAC;AAC5E,UAAQ,IAAI,GAAG,IAAI,aAAa,CAAC;AACjC,UAAQ,IAAI,GAAG,IAAI,6CAA6C,CAAC;AACjE,UAAQ,IAAI,GAAG,IAAI,6CAA6C,CAAC;AACjE,UAAQ,IAAI,EAAE;AAChB;AAEA,SAAS,WACP,SACA,MACA,UAAgC,CAAC,GAClB;AACf,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,QAAQ,MAAM,SAAS,MAAM;AAAA,MACjC,OAAO,QAAQ,SAAS,WAAW;AAAA,MACnC,OAAO;AAAA,IACT,CAAC;AAED,UAAM,GAAG,SAAS,MAAM;AACxB,UAAM,GAAG,SAAS,CAAC,SAAS;AAC1B,UAAI,SAAS,GAAG;AACd,gBAAQ;AAAA,MACV,OAAO;AACL,eAAO,IAAI,MAAM,4BAA4B,IAAI,EAAE,CAAC;AAAA,MACtD;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAEA,SAAS,gBAAgB,KAAa;AACpC,QAAM,gBAAgB,KAAK,KAAK,YAAY;AAC5C,QAAM,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQlB,MAAI,WAAW,aAAa,GAAG;AAC7B,UAAM,UAAU,aAAa,eAAe,OAAO;AAEnD,QAAI,CAAC,QAAQ,SAAS,YAAY,GAAG;AACnC,qBAAe,eAAe,SAAS;AACvC,cAAQ,IAAI,GAAG,MAAM,2BAAsB,CAAC;AAAA,IAC9C,OAAO;AACL,cAAQ,IAAI,GAAG,IAAI,iCAAiC,CAAC;AAAA,IACvD;AAAA,EACF,OAAO;AACL,kBAAc,eAAe,UAAU,KAAK,IAAI,IAAI;AACpD,YAAQ,IAAI,GAAG,MAAM,2BAAsB,CAAC;AAAA,EAC9C;AACF;AAEA,eAAe,kBAAkB,KAAa;AAC5C,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUjB,gBAAc,KAAK,KAAK,kBAAkB,GAAG,QAAQ;AACrD,UAAQ,IAAI,GAAG,MAAM,iCAA4B,CAAC;AACpD;;;AElKA,SAAS,SAAAC,cAAa;AACtB,SAAS,cAAAC,aAAY,eAAAC,cAAa,cAAc,aAAAC,YAAW,gBAAAC,eAAc,cAAAC,mBAAkB;AAC3F,SAAS,QAAAC,OAAM,YAAAC,WAAU,eAAe;AACxC,OAAOC,SAAQ;AACf,SAAS,aAAa;AAkBtB,IAAM,wBAAgD;AAAA,EACpD,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AACT;AAGA,IAAM,uBAA+C;AAAA,EACnD,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AACT;AAGA,IAAM,0BAAkD;AAAA,EACtD,QAAQ;AAAA,EACR,QAAQ;AAAA;AAAA,EACR,OAAO;AACT;AAEA,eAAsB,MAAM,UAAgC,CAAC,GAAG;AAC9D,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,YAAYF,MAAK,KAAK,QAAQ;AACpC,QAAM,gBAAgBA,MAAK,WAAW,YAAY;AAGlD,MAAI,CAACL,YAAW,SAAS,GAAG;AAC1B,YAAQ,MAAMO,IAAG,IAAI,oCAAoC,CAAC;AAC1D,YAAQ,MAAMA,IAAG,IAAI,+BAA+B,CAAC;AACrD,YAAQ,KAAK,CAAC;AAAA,EAChB;AAGA,MAAI,SAAsB,CAAC;AAC3B,MAAIP,YAAW,aAAa,GAAG;AAC7B,QAAI;AACF,YAAM,cAAcG,cAAa,eAAe,OAAO;AACvD,eAAS,MAAM,WAAW;AAAA,IAC5B,SAAS,OAAO;AACd,cAAQ,KAAKI,IAAG,OAAO,qCAAqC,CAAC;AAAA,IAC/D;AAAA,EACF;AAGA,UAAQ,IAAIA,IAAG,IAAI,+BAA0B,CAAC;AAC9C,QAAM,cAAc,QAAQ,MAAM;AAGlC,UAAQ,IAAIA,IAAG,IAAI,qCAAgC,CAAC;AACpD,QAAM,aAAa,KAAK,QAAQ,QAAQ,MAAM;AAG9C,UAAQ,IAAIA,IAAG,IAAI,4BAAuB,CAAC;AAC3C,QAAM,WAAW,KAAK,QAAQ,QAAQ,MAAM;AAG5C,UAAQ,IAAIA,IAAG,IAAI,+BAA0B,CAAC;AAC9C,QAAM,cAAc,KAAK,QAAQ,QAAQ,MAAM;AAE/C,UAAQ,IAAIA,IAAG,KAAKA,IAAG,MAAM,yEAAoE,CAAC,CAAC;AACrG;AAEA,eAAe,cAAc,QAAiC;AAC5D,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,OAAO,CAAC,OAAO;AACrB,QAAI,QAAQ;AACV,WAAK,KAAK,UAAU;AAAA,IACtB;AAEA,UAAM,QAAQR,OAAM,SAAS,MAAM;AAAA,MACjC,OAAO;AAAA,MACP,OAAO;AAAA,IACT,CAAC;AAED,UAAM,GAAG,SAAS,CAAC,QAAQ;AACzB,UAAK,IAA8B,SAAS,UAAU;AACpD,gBAAQ,MAAMQ,IAAG,IAAI,kCAAkC,CAAC;AACxD,gBAAQ,MAAMA,IAAG,IAAI,wDAAwD,CAAC;AAC9E,eAAO,GAAG;AACV;AAAA,MACF;AACA,aAAO,GAAG;AAAA,IACZ,CAAC;AAED,UAAM,GAAG,SAAS,CAAC,SAAS;AAC1B,UAAI,SAAS,GAAG;AACd,gBAAQ;AAAA,MACV,OAAO;AACL,eAAO,IAAI,MAAM,gCAAgC,IAAI,EAAE,CAAC;AAAA,MAC1D;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAEA,eAAe,aACb,KACA,QACA,QACe;AACf,QAAM,oBAAoBF,MAAK,KAAK,UAAU,UAAU;AAGxD,MAAI,CAACL,YAAW,iBAAiB,GAAG;AAClC,YAAQ,IAAIO,IAAG,IAAI,6DAA6D,CAAC;AACjF;AAAA,EACF;AAEA,QAAM,SAAS,OAAO,UAAU,CAAC;AACjC,QAAM,gBAAgB,CAAC,UAAU,UAAU,OAAO;AAGlD,aAAW,aAAa,eAAe;AACrC,UAAM,cAAc,OAAO,SAAS,KAAK,CAAC;AAG1C,QAAI,YAAY,YAAY,OAAO;AACjC;AAAA,IACF;AAGA,UAAM,cAAc,YAAY,gBAAgB,sBAAsB,SAAS;AAC/E,QAAI,CAAC,aAAa;AAChB,cAAQ,KAAKA,IAAG,OAAO,6CAA6C,SAAS,YAAY,CAAC;AAC1F;AAAA,IACF;AAEA,UAAM,WAAWF,MAAK,KAAK,WAAW;AAGtC,QAAI;AACF,6BAAuB,mBAAmB,QAAQ;AAClD,cAAQ,IAAIE,IAAG,MAAM,+BAA0B,SAAS,WAAM,WAAW,EAAE,CAAC;AAAA,IAC9E,SAAS,OAAO;AACd,cAAQ,MAAMA,IAAG,IAAI,uCAAkC,SAAS,KAAK,KAAK,EAAE,CAAC;AAAA,IAC/E;AAAA,EACF;AAGA,MAAI,QAAQ;AACV,UAAM,mBAAmB,KAAK,MAAM;AAAA,EACtC;AACF;AAEA,eAAe,mBACb,KACA,QACe;AAEf,QAAM,eAAe,iBAAiB,GAAG;AAEzC,aAAW,mBAAmB,cAAc;AAC1C,UAAM,qBAAqBF,MAAK,iBAAiB,UAAU;AAE3D,QAAI,CAACL,YAAW,kBAAkB,GAAG;AACnC;AAAA,IACF;AAGA,UAAM,eAAe,gBAClB,QAAQ,KAAK,EAAE,EACf,QAAQ,aAAa,EAAE,EACvB,QAAQ,OAAO,EAAE,EACjB,QAAQ,OAAO,EAAE;AACpB,UAAM,oBAAoB,eAAeK,MAAK,KAAK,YAAY,IAAI;AAEnE,UAAM,SAAS,OAAO,UAAU,CAAC;AACjC,UAAM,gBAAgB,CAAC,UAAU,UAAU,OAAO;AAGlD,eAAW,aAAa,eAAe;AACrC,YAAM,cAAc,OAAO,SAAS,KAAK,CAAC;AAE1C,UAAI,YAAY,YAAY,OAAO;AACjC;AAAA,MACF;AAEA,YAAM,cAAc,YAAY,gBAAgB,sBAAsB,SAAS;AAC/E,UAAI,CAAC,aAAa;AAChB;AAAA,MACF;AAGA,YAAM,WAAWA,MAAK,mBAAmB,WAAW;AAEpD,UAAI;AACF,+BAAuB,oBAAoB,QAAQ;AACnD,gBAAQ,IAAIE,IAAG,MAAM,sCAAiC,SAAS,OAAO,YAAY,WAAM,WAAW,EAAE,CAAC;AAAA,MACxG,SAAS,OAAO;AACd,gBAAQ,MAAMA,IAAG,IAAI,8CAAyC,SAAS,OAAO,YAAY,KAAK,KAAK,EAAE,CAAC;AAAA,MACzG;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,iBAAiB,UAAkB,cAAsB,UAAU,UAAoB,CAAC,GAAa;AAC5G,MAAI;AACF,UAAM,UAAUN,aAAY,aAAa,EAAE,eAAe,KAAK,CAAC;AAEhE,eAAW,SAAS,SAAS;AAE3B,UAAI,MAAM,KAAK,WAAW,GAAG,KAAK,MAAM,SAAS,UAAU;AACzD;AAAA,MACF;AACA,UAAI,MAAM,SAAS,kBAAkB,MAAM,SAAS,UAAU,MAAM,SAAS,QAAQ;AACnF;AAAA,MACF;AAEA,YAAM,WAAWI,MAAK,aAAa,MAAM,IAAI;AAE7C,UAAI,MAAM,YAAY,GAAG;AACvB,YAAI,MAAM,SAAS,YAAY,aAAaA,MAAK,UAAU,QAAQ,GAAG;AACpE,kBAAQ,KAAK,QAAQ;AAAA,QACvB,OAAO;AACL,2BAAiB,UAAU,UAAU,OAAO;AAAA,QAC9C;AAAA,MACF;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AAAA,EAEhB;AAEA,SAAO;AACT;AAMA,SAAS,uBAAuB,QAAgB,MAAoB;AAElE,MAAI,CAACL,YAAW,IAAI,GAAG;AACrB,IAAAE,WAAU,MAAM,EAAE,WAAW,KAAK,CAAC;AAAA,EACrC;AAEA,QAAM,UAAUD,aAAY,QAAQ,EAAE,eAAe,KAAK,CAAC;AAE3D,aAAW,SAAS,SAAS;AAC3B,UAAM,aAAaI,MAAK,QAAQ,MAAM,IAAI;AAC1C,UAAM,WAAWA,MAAK,MAAM,MAAM,IAAI;AAEtC,QAAI,MAAM,YAAY,GAAG;AAEvB,6BAAuB,YAAY,QAAQ;AAAA,IAC7C,OAAO;AAEL,UAAI,MAAM,SAAS,YAAY;AAC7B;AAAA,MACF;AAGA,UAAIL,YAAW,QAAQ,GAAG;AACxB,cAAM,WAAWM,UAAS,UAAU,QAAQ,QAAQ,CAAC;AACrD,cAAM,UAAU,QAAQ,QAAQ;AAChC,cAAM,aAAaD,MAAK,MAAM,GAAG,QAAQ,OAAO,OAAO,EAAE;AAEzD,YAAI;AACF,UAAAD,YAAW,UAAU,UAAU;AAC/B,kBAAQ,IAAIG,IAAG,IAAI,uCAAkC,MAAM,IAAI,WAAMD,UAAS,UAAU,CAAC,EAAE,CAAC;AAAA,QAC9F,SAAS,OAAO;AACd,kBAAQ,KAAKC,IAAG,OAAO,+BAA0B,MAAM,IAAI,eAAe,CAAC;AAC3E;AAAA,QACF;AAAA,MACF;AAGA,mBAAa,YAAY,QAAQ;AAAA,IACnC;AAAA,EACF;AACF;AAKA,eAAe,WACb,KACA,QACA,QACe;AACf,QAAM,kBAAkBF,MAAK,KAAK,UAAU,QAAQ;AAGpD,MAAI,CAACL,YAAW,eAAe,GAAG;AAChC,YAAQ,IAAIO,IAAG,IAAI,0DAA0D,CAAC;AAC9E;AAAA,EACF;AAEA,QAAM,SAAS,OAAO,UAAU,CAAC;AACjC,QAAM,gBAAgB,CAAC,UAAU,UAAU,OAAO;AAGlD,aAAW,aAAa,eAAe;AACrC,UAAM,cAAc,OAAO,SAAS,KAAK,CAAC;AAG1C,QAAI,YAAY,YAAY,OAAO;AACjC;AAAA,IACF;AAGA,UAAM,aAAa,YAAY,eAAe,qBAAqB,SAAS;AAC5E,QAAI,CAAC,YAAY;AACf,cAAQ,KAAKA,IAAG,OAAO,4CAA4C,SAAS,YAAY,CAAC;AACzF;AAAA,IACF;AAEA,UAAM,WAAWF,MAAK,KAAK,UAAU;AAGrC,QAAI;AACF,6BAAuB,iBAAiB,QAAQ;AAChD,cAAQ,IAAIE,IAAG,MAAM,6BAAwB,SAAS,WAAM,UAAU,EAAE,CAAC;AAAA,IAC3E,SAAS,OAAO;AACd,cAAQ,MAAMA,IAAG,IAAI,qCAAgC,SAAS,KAAK,KAAK,EAAE,CAAC;AAAA,IAC7E;AAAA,EACF;AAGA,MAAI,QAAQ;AACV,UAAM,iBAAiB,KAAK,MAAM;AAAA,EACpC;AACF;AAKA,eAAe,iBACb,KACA,QACe;AACf,QAAM,eAAe,iBAAiB,GAAG;AAEzC,aAAW,mBAAmB,cAAc;AAC1C,UAAM,mBAAmBF,MAAK,iBAAiB,QAAQ;AAEvD,QAAI,CAACL,YAAW,gBAAgB,GAAG;AACjC;AAAA,IACF;AAEA,UAAM,eAAe,gBAClB,QAAQ,KAAK,EAAE,EACf,QAAQ,aAAa,EAAE,EACvB,QAAQ,OAAO,EAAE,EACjB,QAAQ,OAAO,EAAE;AACpB,UAAM,oBAAoB,eAAeK,MAAK,KAAK,YAAY,IAAI;AAEnE,UAAM,SAAS,OAAO,UAAU,CAAC;AACjC,UAAM,gBAAgB,CAAC,UAAU,UAAU,OAAO;AAElD,eAAW,aAAa,eAAe;AACrC,YAAM,cAAc,OAAO,SAAS,KAAK,CAAC;AAE1C,UAAI,YAAY,YAAY,OAAO;AACjC;AAAA,MACF;AAEA,YAAM,aAAa,YAAY,eAAe,qBAAqB,SAAS;AAC5E,UAAI,CAAC,YAAY;AACf;AAAA,MACF;AAEA,YAAM,WAAWA,MAAK,mBAAmB,UAAU;AAEnD,UAAI;AACF,+BAAuB,kBAAkB,QAAQ;AACjD,gBAAQ,IAAIE,IAAG,MAAM,oCAA+B,SAAS,OAAO,YAAY,WAAM,UAAU,EAAE,CAAC;AAAA,MACrG,SAAS,OAAO;AACd,gBAAQ,MAAMA,IAAG,IAAI,4CAAuC,SAAS,OAAO,YAAY,KAAK,KAAK,EAAE,CAAC;AAAA,MACvG;AAAA,IACF;AAAA,EACF;AACF;AAKA,eAAe,cACb,KACA,QACA,QACe;AACf,QAAM,qBAAqBF,MAAK,KAAK,UAAU,WAAW;AAG1D,MAAI,CAACL,YAAW,kBAAkB,GAAG;AACnC,YAAQ,IAAIO,IAAG,IAAI,gEAAgE,CAAC;AACpF;AAAA,EACF;AAEA,QAAM,SAAS,OAAO,UAAU,CAAC;AACjC,QAAM,gBAAgB,CAAC,UAAU,UAAU,OAAO;AAGlD,aAAW,aAAa,eAAe;AACrC,UAAM,cAAc,OAAO,SAAS,KAAK,CAAC;AAG1C,QAAI,YAAY,YAAY,OAAO;AACjC;AAAA,IACF;AAGA,UAAM,gBAAgB,YAAY,kBAAkB,wBAAwB,SAAS;AACrF,QAAI,CAAC,eAAe;AAClB,cAAQ,KAAKA,IAAG,OAAO,+CAA+C,SAAS,YAAY,CAAC;AAC5F;AAAA,IACF;AAEA,UAAM,WAAWF,MAAK,KAAK,aAAa;AAGxC,QAAI;AACF,6BAAuB,oBAAoB,QAAQ;AACnD,cAAQ,IAAIE,IAAG,MAAM,gCAA2B,SAAS,WAAM,aAAa,EAAE,CAAC;AAAA,IACjF,SAAS,OAAO;AACd,cAAQ,MAAMA,IAAG,IAAI,wCAAmC,SAAS,KAAK,KAAK,EAAE,CAAC;AAAA,IAChF;AAAA,EACF;AAGA,MAAI,QAAQ;AACV,UAAM,oBAAoB,KAAK,MAAM;AAAA,EACvC;AACF;AAKA,eAAe,oBACb,KACA,QACe;AACf,QAAM,eAAe,iBAAiB,GAAG;AAEzC,aAAW,mBAAmB,cAAc;AAC1C,UAAM,sBAAsBF,MAAK,iBAAiB,WAAW;AAE7D,QAAI,CAACL,YAAW,mBAAmB,GAAG;AACpC;AAAA,IACF;AAEA,UAAM,eAAe,gBAClB,QAAQ,KAAK,EAAE,EACf,QAAQ,aAAa,EAAE,EACvB,QAAQ,OAAO,EAAE,EACjB,QAAQ,OAAO,EAAE;AACpB,UAAM,oBAAoB,eAAeK,MAAK,KAAK,YAAY,IAAI;AAEnE,UAAM,SAAS,OAAO,UAAU,CAAC;AACjC,UAAM,gBAAgB,CAAC,UAAU,UAAU,OAAO;AAElD,eAAW,aAAa,eAAe;AACrC,YAAM,cAAc,OAAO,SAAS,KAAK,CAAC;AAE1C,UAAI,YAAY,YAAY,OAAO;AACjC;AAAA,MACF;AAEA,YAAM,gBAAgB,YAAY,kBAAkB,wBAAwB,SAAS;AACrF,UAAI,CAAC,eAAe;AAClB;AAAA,MACF;AAEA,YAAM,WAAWA,MAAK,mBAAmB,aAAa;AAEtD,UAAI;AACF,+BAAuB,qBAAqB,QAAQ;AACpD,gBAAQ,IAAIE,IAAG,MAAM,uCAAkC,SAAS,OAAO,YAAY,WAAM,aAAa,EAAE,CAAC;AAAA,MAC3G,SAAS,OAAO;AACd,gBAAQ,MAAMA,IAAG,IAAI,+CAA0C,SAAS,OAAO,YAAY,KAAK,KAAK,EAAE,CAAC;AAAA,MAC1G;AAAA,IACF;AAAA,EACF;AACF;;;AHveA,QACG,KAAK,aAAa,EAClB,YAAY,2CAA2C,EACvD,QAAQ,OAAO;AAGlB,QACG,QAAQ,MAAM,EACd,YAAY,2CAA2C,EACvD,OAAO,qBAAqB,wCAAwC,EACpE,OAAO,cAAc,6BAA6B,EAClD,OAAO,oBAAoB,8BAA8B,EACzD,OAAO,IAAI;AAGd,QACG,QAAQ,SAAS,EAAE,WAAW,MAAM,CAAC,EACrC,YAAY,2DAA2D,EACvE,OAAO,YAAY,mCAAmC,EACtD,mBAAmB,IAAI,EACvB,OAAO,YAAY;AAClB,QAAM,SAAS,QAAQ,KAAK,SAAS,UAAU;AAC/C,QAAM,MAAM,EAAE,OAAO,CAAC;AACxB,CAAC;AAEH,QACG,QAAQ,QAAQ,EAChB,YAAY,6CAA6C,EACzD,mBAAmB,IAAI,EACvB,OAAO,MAAM,YAAY,QAAQ,CAAC;AAGrC,QACG,UAAU,qBAAqB,EAC/B,mBAAmB,IAAI,EACvB,OAAO,CAAC,YAAoB,YAAY,OAAO,CAAC;AAEnD,SAAS,YAAY,SAAiB;AACpC,QAAM,OAAO,QAAQ,KAAK,MAAM,QAAQ,KAAK,QAAQ,OAAO,CAAC;AAE7D,UAAQ,IAAIC,IAAG,IAAI,gBAAW,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC;AAE/C,QAAM,QAAQC,OAAM,SAAS,MAAM;AAAA,IACjC,OAAO;AAAA,IACP,OAAO;AAAA,EACT,CAAC;AAED,QAAM,GAAG,SAAS,CAAC,QAAQ;AACzB,QAAK,IAA8B,SAAS,UAAU;AACpD,cAAQ,MAAMD,IAAG,IAAI,kCAAkC,CAAC;AACxD,cAAQ,MAAMA,IAAG,IAAI,wDAAwD,CAAC;AAC9E,cAAQ,KAAK,CAAC;AAAA,IAChB;AACA,YAAQ,MAAMA,IAAG,IAAI,UAAU,IAAI,OAAO,EAAE,CAAC;AAC7C,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AAED,QAAM,GAAG,SAAS,CAAC,SAAS;AAC1B,YAAQ,KAAK,QAAQ,CAAC;AAAA,EACxB,CAAC;AACH;AAEA,QAAQ,MAAM;","names":["spawn","pc","spawn","existsSync","readdirSync","mkdirSync","readFileSync","renameSync","join","basename","pc","pc","spawn"]}